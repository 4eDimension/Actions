name: Codesign Product
description: Submit product to notary

inputs:
  sign:
    required: true
    type: string
  keychain:
    required: true
    type: string
  apple_id:
    required: true
    type: string 
  team_id:
    required: true
    type: string 
  password:
    required: true
    type: string 
  product_path:
    required: true
    type: string
  dmg_path:
    required: true
    type: string

outputs:
  product_path: 
    value: ${{ inputs.product_path }}
  dmg_path: 
    value: ${{ inputs.dmg_path }}
  notarization_status:
    value: ${{ steps.notarytool.outputs.notarization_status }}

runs:
  using: "composite"
  steps:

    - name: setup
      id: setup
      run: |
        echo "dmg_path=${{ inputs.dmg_path }}" >> $GITHUB_OUTPUT
        curl "${entitlements_url}" -o entitlements.plist -sL
        echo "entitlements_path=${GITHUB_WORKSPACE}/entitlements.plist" >> $GITHUB_OUTPUT
      shell: bash
      env:
        path: ${{ inputs.product_path }}
        entitlements_url: 'https://raw.githubusercontent.com/miyako/4D/v1/entitlements.plist'

    - name: Normalize ALL WebViewerCEF bundles (helpers exec must not be symlinks)
      shell: bash
      run: |
        set -euo pipefail
        shopt -s nullglob

        echo "üîé Scan des r√©pertoires *WebViewerCEF.bundle/Contents/Frameworks* dans ${GITHUB_WORKSPACE}"

        py_resolve='import os,sys; base=sys.argv[1]; tgt=sys.argv[2]; print(os.path.abspath(os.path.join(base, tgt)))'

        FOUND=0
        while IFS= read -r -d '' BUNDLE_ROOT; do
          FOUND=1
          echo "üì¶ Bundle: $BUNDLE_ROOT"

          SRC_CEF="${BUNDLE_ROOT}/Chromium Embedded Framework.framework"
          if [ ! -d "$SRC_CEF" ]; then
            echo "‚ùå CEF introuvable dans $BUNDLE_ROOT"; exit 1
          fi

          while IFS= read -r -d '' APP; do
            NAME="$(basename "$APP" .app)"
            EXE="$APP/Contents/MacOS/$NAME"

            # 1) L'ex√©cutable principal ne doit pas √™tre un symlink
            if [ -L "$EXE" ]; then
              TGT="$(readlink "$EXE")"
              RESOLVED=$(python3 -c "$py_resolve" "$(dirname "$EXE")" "$TGT")
              if [ ! -f "$RESOLVED" ]; then
                echo "‚ùå Cible du symlink introuvable: $EXE -> $TGT"; exit 1
              fi
              echo "ü™Ñ Remplace symlink ex√©cutable: $EXE  (-> $TGT)"
              rm -f "$EXE"
              /usr/bin/ditto "$RESOLVED" "$EXE"
              chmod 755 "$EXE"
            fi

            # 2) Chaque helper doit avoir sa copie locale du framework CEF
            DEST_CEF="$APP/Contents/Frameworks/Chromium Embedded Framework.framework"
            if [ -L "$DEST_CEF" ]; then
              echo "ü™Ñ Supprime symlink CEF dans $APP"
              rm -f "$DEST_CEF"
            fi
            if [ ! -d "$DEST_CEF" ]; then
              echo "üìö Copie CEF local dans: $DEST_CEF"
              /usr/bin/ditto "$SRC_CEF" "$DEST_CEF"
            fi

          done < <(find "$BUNDLE_ROOT" -type d -name "4D Helper*.app" -print0)

        done < <(find "${GITHUB_WORKSPACE}" -type d -path "*/WebViewerCEF.bundle/Contents/Frameworks" -print0)

        if [ $FOUND -eq 0 ]; then
          echo "‚ÑπÔ∏è Aucun WebViewerCEF.bundle trouv√© (ce n‚Äôest pas bloquant)"
        fi

    - name: Preflight ‚Äî aucun ex√©cutable de helper ne doit √™tre un symlink
      shell: bash
      run: |
        set -euo pipefail
        SYMLINKS_FOUND=0

        while IFS= read -r -d '' SYM; do
          if [ $SYMLINKS_FOUND -eq 0 ]; then
            echo "‚ùå Symlinks d'ex√©cutables trouv√©s :"
          fi
          echo " - $SYM"
          SYMLINKS_FOUND=1
        done < <(find "${GITHUB_WORKSPACE}" -type l -path "*/4D Helper*.app/Contents/MacOS/*" -print0)

        if [ $SYMLINKS_FOUND -eq 1 ]; then
          exit 1
        fi

        echo "‚úÖ OK ‚Äî aucun symlink executable dans les helpers"

    - name: Codesign (r√©solution symlinks + timestamp + retries)
      shell: bash
      run: |
        set -euo pipefail
        echo "=== Codesign start ==="
        echo "product_path=${product_path}"
        echo "sign='${sign}'"
        echo "entitlements='${entitlements_path:-}'"

        # nettoyage xattr (quarantine) - best-effort
        echo "üßπ Nettoyage xattr (quarantine) sur ${product_path}..."
        xattr -rc "${product_path}" 2>/dev/null || true

        # unlock keychain (best-effort) ; si tu as KEYCHAIN_PWD dans le job, mets-le
        if [[ -n "${keychain:-}" ]]; then
          if [[ -n "${KEYCHAIN_PWD:-}" ]]; then
            echo "üîê Unlock keychain (with password) : ${keychain}"
            security unlock-keychain -p "${KEYCHAIN_PWD}" "${keychain}" || true
            security set-key-partition-list -S apple-tool:,apple: -s -k "${KEYCHAIN_PWD}" "${keychain}" >/dev/null 2>&1 || true
          else
            echo "üîê Unlock keychain (best-effort no password) : ${keychain}"
            security unlock-keychain -u "${keychain}" >/dev/null 2>&1 || true
          fi
        else
          echo "‚ö†Ô∏è No keychain provided, using default keychains"
        fi

        # produit type detection
        if [[ "${product_path}" == *.app ]]; then
          product_type="app"
        elif [[ "${product_path}" == *.4dbase ]]; then
          product_type="4dbase"
        elif [[ "${product_path}" == *.4darchive ]]; then
          product_type="4darchive"
        else
          product_type="other"
        fi
        echo "üì¶ Type d√©tect√©: ${product_type}"

        # helper: detect fatal error in codesign output
        is_fatal_output() {
          local o="$1"
          if printf "%s" "$o" | grep -qiE "no identity found|not found in keychain|password|keychain|code object is not signed at all|resource fork|invalid|not allowed|permission denied"; then
            return 0
          fi
          return 1
        }

        # helper: resolve symlink path to absolute target and replace symlink by a copy (ditto)
        resolve_and_replace_symlink() {
          local path="$1"
          if [ -L "$path" ]; then
            echo "üîó Found symlink -> resolving and replacing: $path"
            TGT="$(readlink "$path")" || TGT=""
            if [ -z "$TGT" ]; then
              echo "‚ö†Ô∏è readlink returned empty for $path"
              return 0
            fi
            # Resolve relative target to absolute using python if available
            if command -v python3 >/dev/null 2>&1; then
              RESOLVED=$(python3 - <<PY - "$path" "$TGT"
    import os,sys
    base=os.path.dirname(sys.argv[1])
    tgt=sys.argv[2]
    print(os.path.abspath(os.path.join(base,tgt)))
    PY
    )
            elif command -v python >/dev/null 2>&1; then
              RESOLVED=$(python - <<PY - "$path" "$TGT"
    import os,sys
    base=os.path.dirname(sys.argv[1])
    tgt=sys.argv[2]
    print(os.path.abspath(os.path.join(base,tgt)))
    PY
    )
            else
              # fallback: attempt join
              RESOLVED="$(cd "$(dirname "$path")" && echo "$(pwd)/$TGT")"
            fi

            if [ -f "$RESOLVED" ]; then
              echo "  -> resolving to $RESOLVED ; copying into place..."
              rm -f "$path"
              /usr/bin/ditto "$RESOLVED" "$path"
              chmod +x "$path" || true
              echo "  -> replaced symlink with real file"
            else
              echo "‚ö†Ô∏è R√©solution cible introuvable: ${RESOLVED} (le symlink reste non modifi√©)"
            fi
          fi
        }

        # function: sign with timestamp + retry (10 attempts, 3s wait)
        sign_with_timestamp_retry() {
          local item="$1"
          # entitlements only used when signing top-level .app and file exists
          local ent_opt=()
          if [[ "${item}" == *.app ]] && [[ -n "${entitlements_path:-}" ]] && [[ -f "${entitlements_path}" ]]; then
            ent_opt=(--entitlements "${entitlements_path}")
          fi

          local attempt=1
          local max_attempts=10
          while [ $attempt -le $max_attempts ]; do
            echo "[sign attempt ${attempt}/${max_attempts}] codesign -> ${item}"
            # run codesign and capture output
            output=$(codesign --force --options runtime --strict --timestamp "${ent_opt[@]}" --sign "${sign}" "${item}" 2>&1) || status=$?
            status=${status:-0}
            if [ "$status" -eq 0 ]; then
              echo "‚úÖ signed: ${item} (attempt ${attempt})"
              # verify immediately and dump details for logs
              codesign --verify --strict --verbose=2 "${item}" 2>&1 || echo "‚ö†Ô∏è verification warning for ${item}"
              echo "---- codesign -dvvv ${item} ----"
              codesign -dvvv "${item}" 2>&1 || true
              echo "---------------------------------"
              return 0
            fi

            echo "‚õî codesign non-zero for ${item} (attempt ${attempt}). Output:"
            echo "${output}"
            if is_fatal_output "${output}"; then
              echo "‚ùå Erreur fatale d√©tect√©e lors de la signature de ${item} -> abort."
              echo "---- DEBUG codesign -dvvv ${item} (post-fatal) ----"
              codesign -dvvv "${item}" 2>&1 || true
              echo "--------------------------------------------------"
              exit 1
            fi

            # If timestamp server errors => retry
            if printf "%s" "$output" | grep -qiE "timestamp service is not available|unable to get timestamp|no connection|timed out"; then
              echo "‚ö†Ô∏è TSA inaccessible pour ${item} ‚Äî attente 3s puis nouvelle tentative..."
              sleep 3
              attempt=$((attempt+1))
              continue
            fi

            # generic retry with small backoff
            echo "‚ö†Ô∏è Tentative ${attempt} √©chou√©e pour ${item}, retry dans 3s..."
            sleep 3
            attempt=$((attempt+1))
          done

          echo "‚ùå √âchec apr√®s ${max_attempts} tentatives pour ${item}"
          return 1
        }

        # function to sign framework: sign internal binary first then framework
        sign_framework() {
          local fw="$1"
          echo "üîß framework: ${fw}"
          # resolve symlink if framework binary itself is symlink (rare)
          local name="$(basename "$fw" .framework)"
          local candidates=( "$fw/Versions/A/$name" "$fw/Versions/Current/$name" "$fw/$name" )
          local found=""
          for c in "${candidates[@]}"; do
            if [ -f "$c" ]; then found="$c"; break; fi
          done
          if [ -z "$found" ]; then
            found=$(find "$fw" -type f -perm +111 -maxdepth 3 -print -quit || true)
          fi
          if [ -n "$found" ]; then
            resolve_and_replace_symlink "$found" || true
            sign_with_timestamp_retry "$found" || return 1
          fi
          sign_with_timestamp_retry "$fw" || return 1
        }

        # function to sign bundle/plugin/kext: sign its executable(s) then the bundle
        sign_bundle_like() {
          local b="$1"
          echo "üîå bundle/plugin/kext: ${b}"
          # sign executables in Contents/MacOS first
          if [ -d "${b}/Contents/MacOS" ]; then
            find "${b}/Contents/MacOS" -type f -perm +111 -print0 | while IFS= read -r -d '' exe; do
              resolve_and_replace_symlink "$exe" || true
              sign_with_timestamp_retry "$exe" || return 1
            done
          else
            # fallback: first executable found
            exe=$(find "$b" -type f -perm +111 -maxdepth 6 -print -quit || true)
            if [ -n "$exe" ]; then
              resolve_and_replace_symlink "$exe" || true
              sign_with_timestamp_retry "$exe" || return 1
            fi
          fi
          sign_with_timestamp_retry "$b" || return 1
        }

        # --- MAIN: sign everything useful inside product_path -- careful with null-bytes / spaces
        echo "‚û°Ô∏è Signature des ex√©cutables (.dylib .so, exes) dans ${product_path}..."
        find "${product_path}" -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -print0 |
        while IFS= read -r -d '' f; do
          resolve_and_replace_symlink "$f" || true
          sign_with_timestamp_retry "$f" || exit 1
        done

        echo "‚û°Ô∏è Signature des frameworks..."
        find "${product_path}" -type d -name "*.framework" -print0 |
        while IFS= read -r -d '' fw; do
          sign_framework "$fw" || exit 1
        done

        echo "‚û°Ô∏è Signature des bundles/plugins/kexts..."
        find "${product_path}" -type d \( -name "*.bundle" -o -name "*.plugin" -o -name "*.kext" \) -print0 |
        while IFS= read -r -d '' b; do
          sign_bundle_like "$b" || exit 1
        done

        echo "‚û°Ô∏è Signature des sub-apps (helpers) trouv√©es..."
        find "${product_path}" -type d -name "*.app" -print0 |
        while IFS= read -r -d '' sa; do
          # skip top-level if it's the top-level app (we'll sign it later)
          if [[ "${product_type}" == "app" && "$(realpath "$sa")" == "$(realpath "$product_path")" ]]; then
            continue
          fi
          echo "  -> sub-app: ${sa}"
          # sign internals first
          find "$sa" -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -print0 | while IFS= read -r -d '' sf; do
            resolve_and_replace_symlink "$sf" || true
            sign_with_timestamp_retry "$sf" || exit 1
          done
          find "$sa" -type d -name "*.framework" -print0 | while IFS= read -r -d '' sfw; do
            sign_framework "$sfw" || exit 1
          done
          find "$sa" -type d \( -name "*.bundle" -o -name "*.plugin" -o -name "*.kext" \) -print0 | while IFS= read -r -d '' sb; do
            sign_bundle_like "$sb" || exit 1
          done
          # final sign of subapp
          sign_with_timestamp_retry "$sa" || exit 1
        done

        # Final: sign top-level .app (with --deep) OR skip container for .4dbase/.4darchive
        if [[ "${product_type}" == "app" ]]; then
          echo "‚û°Ô∏è Final: signing top-level .app with --deep + timestamp (retry)..."
          attempt=1
          max_attempts=10
          while [ $attempt -le $max_attempts ]; do
            echo "[final sign attempt ${attempt}/${max_attempts}] codesign --deep ${product_path}"
            out=$(codesign --force --options runtime --strict --deep --timestamp --entitlements "${entitlements_path:-}" --sign "${sign}" "${product_path}" 2>&1) || status=$?
            status=${status:-0}
            if [ "$status" = "0" ]; then
              echo "‚úÖ Final .app signed"
              break
            fi
            echo "‚õî Final sign failed (attempt ${attempt}), output:"
            echo "${out}"
            if is_fatal_output "${out}"; then
              echo "‚ùå Erreur fatale pendant final sign -> abort."
              exit 1
            fi
            sleep 3
            attempt=$((attempt+1))
          done
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå √âchec final .app apr√®s ${max_attempts} tentatives"
            exit 1
          fi

          echo "üîé V√©rification finale : codesign --verify --deep"
          codesign --verify --deep --strict --verbose=2 "${product_path}" || { echo "‚ùå Verification finale √©chou√©e"; exit 1; }
        else
          echo "‚ÑπÔ∏è Produit non .app (${product_type}) ‚Äî container SKIPPED (c'est voulu pour .4dbase/.4darchive)."
          echo "üîé V√©rification rapide des binaires sign√©s..."
          find "${product_path}" -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -print0 |
          while IFS= read -r -d '' f; do
            codesign --verify --verbose=2 "$f" || { echo "‚ùå Verification failed: $f"; exit 1; }
          done
        fi

        echo "‚úÖ Codesign finished successfully for ${product_path}"
      env:
        sign: ${{ inputs.sign }}
        keychain: ${{ inputs.keychain }}
        product_path: ${{ inputs.product_path }}
        entitlements_path: ${{ steps.setup.outputs.entitlements_path }}

    - name: hdiutil (sparse -> convert)
      id: hdiutil
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      shell: bash
      env:
        product_path: ${{ inputs.product_path }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}
        FS: HFS+                 # ou APFS si tu pr√©f√®res
        FORMAT: UDBZ             # UDBZ (bzip2) ou UDZO (zlib)
        MARGIN_PCT: "50"         # marge % au-dessus de la taille source
        EXTRA_MB: "500"          # marge fixe suppl√©mentaire en MB
        VERIFY: "1"              # 0 pour d√©sactiver verify
      run: |
        set -euo pipefail

        SRC="${product_path}"
        OUT="${dmg_path}"
        VOLNAME="$(basename "${OUT%.dmg}")"
        WORKDIR="$(mktemp -d /tmp/dmgbuild.XXXXXX)"
        MOUNT_DIR="${WORKDIR}/mnt"
        mkdir -p "$MOUNT_DIR"

        # Estimation taille
        SRC_KB=$(du -sk "$SRC" | awk '{print $1}')
        SRC_MB=$(( SRC_KB / 1024 ))
        if [[ $SRC_MB -lt 1 ]]; then SRC_MB=1; fi
        NEEDED_MB=$(( SRC_MB + (SRC_MB * ${MARGIN_PCT} / 100) + ${EXTRA_MB} ))
        if [[ $NEEDED_MB -lt 300 ]]; then NEEDED_MB=300; fi

        # Sparse + montage
        hdiutil create -type SPARSE -fs "${FS}" -volname "${VOLNAME}" -nospotlight \
          -size "${NEEDED_MB}m" -ov "${WORKDIR}/staging.sparseimage"

        hdiutil attach "${WORKDIR}/staging.sparseimage" -nobrowse -noverify -noautoopen -owners on \
          -mountpoint "${MOUNT_DIR}"

        # Copie
        rsync -a --delete "${SRC}" "${MOUNT_DIR}/"

        # D√©montage
        sync
        hdiutil detach "${MOUNT_DIR}" || hdiutil detach -force "${MOUNT_DIR}" || true

        # Compact + conversion
        hdiutil compact "${WORKDIR}/staging.sparseimage" || true
        hdiutil convert "${WORKDIR}/staging.sparseimage" -format "${FORMAT}" -o "${OUT}" -ov

        # Verify optionnel
        if [[ "${VERIFY}" == "1" ]]; then
          hdiutil verify "${OUT}"
        fi

        echo "[‚úì] DMG pr√™t: ${OUT}"

    - name: Debug notarization env vars
      id: debug-notarization
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      run: |
        echo "Apple ID: ${apple_id}"
        echo "Team ID: ${team_id}"
        echo "Password is set: [${#password} characters]"
      shell: bash
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}

    - name: Notarize with Apple NotaryTool and check result (polling)
      id: notarytool
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      shell: bash
      run: |
        set -euo pipefail

        echo "üì¶ Soumission √† Apple NotaryTool..."
        json_output_file="notarytool-submit.json"
        status_file="${GITHUB_WORKSPACE}/notarization_status.txt"

        # soumission (sans --wait)
        xcrun notarytool submit "${dmg_path}" \
          --apple-id "${apple_id}" \
          --team-id "${team_id}" \
          --password "${password}" \
          --output-format json >"$json_output_file"

        echo "üìÑ JSON submit:"
        cat "$json_output_file" || true

        submission_id=$(jq -r '.id // empty' "$json_output_file")
        if [[ -z "$submission_id" ]]; then
          echo "‚ùå Impossible de r√©cup√©rer l‚ÄôID de soumission"
          exit 1
        fi
        echo "üÜî Soumission envoy√©e, ID=$submission_id"

        # Polling (10s) jusqu'√† 1h (360 tentatives)
        attempt=0
        max_attempts=360
        status="In Progress"
        while [[ "$status" == "In Progress" && $attempt -lt $max_attempts ]]; do
          sleep 10
          attempt=$((attempt+1))
          echo "‚è≥ V√©rification notarisation (tentative $attempt)..."
          out=$(xcrun notarytool info "$submission_id" \
            --apple-id "${apple_id}" \
            --team-id "${team_id}" \
            --password "${password}" \
            --output-format json 2>/dev/null || true)
          status=$(echo "$out" | jq -r '.status // empty')
          echo "Statut actuel: ${status:-unknown}"

          # Optionnel: √©crire l‚Äôinstantan√© JSON pour debug
          echo "$out" > "notarytool-info-$attempt.json" || true
        done

        echo "${status:-Unknown}" > "$status_file"
        echo "notarization_status=${status:-Unknown}" >> $GITHUB_OUTPUT

        if [[ "$status" == "Accepted" ]]; then
          echo "‚úÖ Notarisation r√©ussie"
          exit 0
        elif [[ "$status" == "Invalid" ]]; then
          echo "‚ùå Notarisation rejet√©e (Invalid)"
          xcrun notarytool log "$submission_id" \
            --apple-id "${apple_id}" \
            --team-id "${team_id}" \
            --password "${password}" \
            --output-format json || true
          exit 1
        else
          echo "‚ùå Notarisation non termin√©e ou statut inattendu: '${status:-Unknown}'"
          exit 1
        fi
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}
