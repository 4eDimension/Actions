name: Codesign Product
description: Submit product to notary

inputs:
  sign:
    required: true
    type: string
  keychain:
    required: true
    type: string
  apple_id:
    required: true
    type: string 
  team_id:
    required: true
    type: string 
  password:
    required: true
    type: string 
  product_path:
    required: true
    type: string
  dmg_path:
    required: true
    type: string

outputs:
  product_path: 
    value: ${{ inputs.product_path }}
  dmg_path: 
    value: ${{ inputs.dmg_path }}
  notarization_status:
    value: ${{ steps.notarytool.outputs.notarization_status }}

runs:
  using: "composite"
  steps:

    - name: setup
      id: setup
      run: |
        echo "dmg_path=${{ inputs.dmg_path }}" >> $GITHUB_OUTPUT
        curl "${entitlements_url}" -o entitlements.plist -sL
        echo "entitlements_path=${GITHUB_WORKSPACE}/entitlements.plist" >> $GITHUB_OUTPUT
      shell: bash
      env:
        path: ${{ inputs.product_path }}
        entitlements_url: 'https://raw.githubusercontent.com/miyako/4D/v1/entitlements.plist'

    - name: Normalize WebViewerCEF bundle and helpers (no symlinks in MacOS, fix CEF)
      shell: bash
      run: |
        set -e

        echo "üîç Locate WebViewerCEF.bundle/Contents/Frameworks"
        BUNDLE_ROOT=$(find "${GITHUB_WORKSPACE}" -type d -path "*WebViewerCEF.bundle/Contents/Frameworks" | head -n 1)
        if [ -z "${BUNDLE_ROOT}" ]; then
          echo "‚ùå WebViewerCEF.bundle introuvable"
          exit 1
        fi
        echo "‚úÖ ${BUNDLE_ROOT}"

        # Petite aide Python pour chemins relatifs macOS (pas de realpath GNU)
        relpath() { python3 -c 'import os,sys;print(os.path.relpath(sys.argv[2], sys.argv[1]))' "$1" "$2"; }

        # 1) Remplacer l'ex√©cutable principal des helpers s'il est un symlink
        echo "üîß Normalisation des executables Contents/MacOS des 4D Helper*.app"
        find "${BUNDLE_ROOT}" -type d -name "4D Helper*.app" | while IFS= read -r APP; do
          NAME="$(basename "$APP" .app)"
          MACOS_DIR="$APP/Contents/MacOS"
          EXE="$MACOS_DIR/$NAME"
          if [ -L "$EXE" ]; then
            TGT="$(readlink "$EXE")"
            RESOLVED="$EXE"
            # R√©soudre la cible par rapport au dossier du lien
            if [ -e "$(dirname "$EXE")/$TGT" ]; then
              RESOLVED="$(cd "$(dirname "$EXE")" && cd "$(dirname "$TGT")" && pwd)/$(basename "$TGT")"
            fi
            if [ ! -f "$RESOLVED" ]; then
              echo "‚ùå Cible du symlink introuvable pour $EXE -> $TGT"
              exit 1
            fi
            echo "üì¶ Remplacement du symlink ex√©cutable: $EXE  (cible: $RESOLVED)"
            rm -f "$EXE"
            # Copier l‚Äôex√©cutable r√©el dans Contents/MacOS
            /usr/bin/ditto "$RESOLVED" "$EXE"
            chmod 755 "$EXE"
          fi
        done

        # 2) S‚Äôassurer que CEF framework dans le Plugin est une vraie copie locale et que les liens vers lui sont relatifs
        echo "üîß V√©rification du CEF framework dans 4D Helper (Plugin).app"
        PLUGIN_APP=$(find "${BUNDLE_ROOT}" -type d -name "4D Helper (Plugin).app" | head -n 1)
        if [ -n "$PLUGIN_APP" ]; then
          PLUGIN_FW_DIR="$PLUGIN_APP/Contents/Frameworks"
          DEST_CEF="$PLUGIN_FW_DIR/Chromium Embedded Framework.framework"
          # Chercher une source CEF dans le bundle parent (copie saine)
          SRC_CEF=$(find "${BUNDLE_ROOT}/.." -maxdepth 2 -type d -name "Chromium Embedded Framework.framework" | head -n 1)
          if [ -z "$SRC_CEF" ]; then
            echo "‚ùå Source CEF introuvable pour copie"
            exit 1
          fi
          # Si DEST est un lien ou diff√©rent, recr√©er proprement
          if [ -L "$DEST_CEF" ] || [ ! -d "$DEST_CEF" ]; then
            echo "üì¶ Installation locale de CEF dans le plugin"
            rm -rf "$DEST_CEF"
            /usr/bin/ditto "$SRC_CEF" "$DEST_CEF"
          fi

          # Repointer tous les liens vers CEF en chemins relatifs internes au plugin
          find "$PLUGIN_APP" -type l | while IFS= read -r L; do
            T=$(readlink "$L")
            case "$T" in
              *"Chromium Embedded Framework.framework"*)
                NEW=$(relpath "$(dirname "$L")" "$DEST_CEF")
                echo "üîó Fix symlink: $L -> $NEW"
                ln -snf "$NEW" "$L"
              ;;
            esac
          done
        else
          echo "‚ÑπÔ∏è Aucun 4D Helper (Plugin).app trouv√© (ok selon build)."
        fi

        echo "‚úÖ Normalisation termin√©e (plus de symlink ex√©cutable hors MacOS, CEF local & liens relatifs)."

    - name: Codesign
      shell: bash
      run: |
        set -e

        retry_codesign() {
          local target="$1"
          local timestamp_flag="$2"  # Ajouter un param√®tre pour le timestamp
          local attempt=1
          local max_attempts=5
          local delay=5

          while [ $attempt -le $max_attempts ]; do
            echo "[$attempt/$max_attempts] codesign de: $target"

            output=$(codesign --verbose --deep --strict --options=runtime $timestamp_flag \
              --force --sign "${sign}" --keychain "${keychain}" \
              --entitlements "${entitlements_path}" "$target" 2>&1)
            status=$?
            echo "$output"

            if [ $status -eq 0 ]; then
              echo "‚úÖ codesign r√©ussi pour $target"
              return 0
            fi

            if echo "$output" | grep -qiE "no identity found|password|resource fork|invalid|not found in keychain|code object is not signed at all"; then
              echo "‚ùå Erreur fatale d√©tect√©e, arr√™t imm√©diat."
              return 1
            fi

            echo "‚ö†Ô∏è Tentative $attempt √©chou√©e, nouvelle tentative dans ${delay}s..."
            attempt=$(( attempt + 1 ))
            sleep $delay
            delay=$(( delay * 2 ))
          done

          echo "‚ùå √âchec apr√®s $max_attempts tentatives pour $target"
          return 1
        }

        IFS=$'\n'; set -f

        echo "=== √âtape 1 : signer tous les binaires externes (avec timestamp) ==="
        find "${product_path}" -type f \( -perm -111 -o -name "*.dylib" -o -name "*.so" \) \
          ! -path "*.4dbase/*" ! -path "*.4darchive/*" \
          | while IFS= read -r f; do
              retry_codesign "$f" "--timestamp" || exit 1
            done

        echo "=== √âtape 2 : signer les frameworks (avec timestamp) ==="
        find "${product_path}" -type d -name "*.framework" \
          | while IFS= read -r f; do
              retry_codesign "$f" "--timestamp" || exit 1
            done

        echo "=== √âtape 3 : signer les bundles/plugins/kexts (avec timestamp) ==="
        find "${product_path}" -type d \( -name "*.bundle" -o -name "*.plugin" -o -name "*.kext" \) \
          | while IFS= read -r f; do
              retry_codesign "$f" "--timestamp" || exit 1
            done

        echo "=== √âtape 4 : signer les .4dbase et .4darchive (avec timestamp) ==="
        find "${product_path}" -type d \( -name "*.4dbase" -o -name "*.4darchive" \) \
          | while IFS= read -r bundle; do
              echo "üìÇ Signing binaries inside: $bundle"
              find "$bundle" -type f \( -perm -111 -o -name "*.dylib" -o -name "*.so" \) \
                | while IFS= read -r f; do
                    retry_codesign "$f" "--timestamp" || exit 1
                  done
            done

        echo "=== √âtape 5 : signer toutes les apps internes (SANS timestamp) ==="
        find "${product_path}" -type d -name "*.app" \
          | while IFS= read -r f; do
              retry_codesign "$f" "" || exit 1
            done

        echo "=== √âtape 6 : signature finale du paquet racine (avec timestamp si c'est .app) ==="
        if [[ "${product_path}" == *.app ]]; then
          echo "üì¶ Signature finale de l‚Äôapp principale : ${product_path}"
          retry_codesign "${product_path}" "--timestamp" || exit 1
        else
          echo "‚ÑπÔ∏è ${product_path} n‚Äôest pas une .app/.4dbase/.4darchive, pas de signature racine."
        fi

        echo "=== √âtape 7 : v√©rification stricte sur tous les binaires sign√©s ==="
        find "${product_path}" -type f \( -perm -111 -o -name "*.dylib" -o -name "*.so" \) \
          | while IFS= read -r f; do
              codesign --verify --strict --verbose=2 "$f" || exit 1
            done

        echo "‚úÖ Tous les composants ont √©t√© sign√©s et v√©rifi√©s correctement."
      env:
        sign: ${{ inputs.sign }}
        keychain: ${{ inputs.keychain }}
        product_path: ${{ inputs.product_path }}
        entitlements_path: ${{ steps.setup.outputs.entitlements_path }}

    - name: hdiutil (sparse -> convert)
      id: hdiutil
      shell: bash
      env:
        product_path: ${{ inputs.product_path }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}
        FS: HFS+                 # ou APFS si tu pr√©f√®res
        FORMAT: UDBZ             # UDBZ (bzip2) ou UDZO (zlib)
        MARGIN_PCT: "50"         # marge % au-dessus de la taille source
        EXTRA_MB: "500"          # marge fixe suppl√©mentaire en MB
        VERIFY: "1"              # 0 pour d√©sactiver verify
      run: |
        set -euo pipefail

        SRC="${product_path}"
        OUT="${dmg_path}"
        VOLNAME="$(basename "${OUT%.dmg}")"   # nom du volume = nom du .dmg
        WORKDIR="$(mktemp -d /tmp/dmgbuild.XXXXXX)"
        LOG="${WORKDIR}/build.log"
        STAGING="${WORKDIR}/staging.sparseimage"
        ATTACH_PLIST="${WORKDIR}/attach.plist"
        MOUNT_DIR="${WORKDIR}/mnt"
        mkdir -p "$MOUNT_DIR"

        echo "[i] Workdir: $WORKDIR"
        echo "[i] SRC=$SRC"
        echo "[i] OUT=$OUT"
        echo "[i] VOLNAME=$VOLNAME"

        if [[ ! -e "$SRC" ]]; then
          echo "[!] Source introuvable: $SRC"
          exit 1
        fi

        # --- Estimation taille (auto) ---
        SRC_KB=$(du -sk "$SRC" | awk '{print $1}')
        SRC_MB=$(( SRC_KB / 1024 ))
        if [[ $SRC_MB -lt 1 ]]; then SRC_MB=1; fi
        NEEDED_MB=$(( SRC_MB + (SRC_MB * ${MARGIN_PCT} / 100) + ${EXTRA_MB} ))
        if [[ $NEEDED_MB -lt 300 ]]; then NEEDED_MB=300; fi
        echo "[i] Payload size: $(du -sh "$SRC" | awk '{print $1}'); staging ceil: ${NEEDED_MB} MB"

        # --- Cr√©ation sparseimage (√©lastique) ---
        hdiutil create -type SPARSE -fs "${FS}" -volname "${VOLNAME}" -nospotlight \
          -size "${NEEDED_MB}m" -ov "${STAGING}"

        # --- Montage contr√¥l√© (pas de /Volumes/test 1) ---
        hdiutil attach "${STAGING}" -nobrowse -noverify -noautoopen -owners on \
          -mountpoint "${MOUNT_DIR}" -plist > "${ATTACH_PLIST}"

        # Petite protection anti-indexation
        touch "${MOUNT_DIR}/.metadata_never_index" || true

        # --- Copie du contenu ---
        rsync -a --delete "${SRC}" "${MOUNT_DIR}/"

        # --- Sync + detach robuste ---
        sync
        mdutil -i off "${MOUNT_DIR}" >/dev/null 2>&1 || true

        detach_ok=0
        for i in {1..8}; do
          if hdiutil detach "${MOUNT_DIR}" -quiet; then
            detach_ok=1; echo "[i] Detached OK"; break
          else
            echo "[warn] Detach failed (try $i). Showing lsof & poking Spotlight/QuickLook‚Ä¶"
            lsof +D "${MOUNT_DIR}" || true
            pkill -f mdworker || true
            pkill -f quicklookd || true
            sleep 2
            if [[ $i -eq 8 ]]; then
              echo "[warn] Forcing detach‚Ä¶"
              hdiutil detach -force "${MOUNT_DIR}" || true
            fi
          fi
        done
        if [[ $detach_ok -eq 0 ]]; then
          echo "[warn] Forced detach may have been needed"
        fi

        # --- Compact avant conversion (r√©duit la sparse) ---
        hdiutil compact "${STAGING}" || true

        # --- Conversion finale (.dmg compress√©) ---
        hdiutil convert "${STAGING}" -format "${FORMAT}" -o "${OUT}" -ov

        # --- Verify (optionnel) ---
        if [[ "${VERIFY}" == "1" ]]; then
          hdiutil verify "${OUT}"
        fi

        echo "[‚úì] DMG pr√™t: ${OUT}"
        echo "[i] Log (temp): ${LOG}"

    - name: Debug notarization env vars
      run: |
        echo "Apple ID: ${apple_id}"
        echo "Team ID: ${team_id}"
        echo "Password is set: [${#password} characters]"
      shell: bash
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}

    - name: Notarize with Apple NotaryTool and check result
      id: notarytool
      shell: bash
      run: |
        echo "üì¶ Soumission √† Apple NotaryTool..."

        json_output_file="notarytool-output.json"
        status_file="${GITHUB_WORKSPACE}/notarization_status.txt"

        # soumission (stdout ‚Üí fichier JSON, stderr ‚Üí console)
        if ! xcrun notarytool submit "${dmg_path}" \
          --apple-id "${apple_id}" \
          --team-id "${team_id}" \
          --password "${password}" \
          --wait \
          --output-format json \
          1>"$json_output_file"; then
          echo "‚ùå Erreur lors de l‚Äôex√©cution de notarytool (avant r√©ception du JSON)."
          exit 1
        fi

        # affichage du JSON brut
        echo "üìÑ JSON brut g√©n√©r√© par notarytool :"
        cat "$json_output_file" || true

        # extraction statut et id
        status=$(jq -r '.status // empty' "$json_output_file" 2>/dev/null || echo "Unknown")
        submission_id=$(jq -r '.id // empty' "$json_output_file" 2>/dev/null || echo "")

        echo "üõ°Ô∏è Statut de notarisation : $status"
        echo "$status" > "$status_file"

        if [[ "$status" == "Accepted" ]]; then
          echo "‚úÖ Notarisation r√©ussie : statut accept√©"
          exit 0
        elif [[ "$status" == "Invalid" ]]; then
          echo "‚ùå La notarisation a √©t√© rejet√©e (Invalid)."
          if [[ -n "$submission_id" ]]; then
            echo "üì• R√©cup√©ration du log Apple pour la soumission : $submission_id"
            xcrun notarytool log "$submission_id" \
              --apple-id "${apple_id}" \
              --team-id "${team_id}" \
              --password "${password}" \
              --output-format normal || true
          fi
          exit 1
        else
          echo "‚ùå La notarisation a √©chou√© avec statut inattendu : '$status'."
          exit 1
        fi
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}