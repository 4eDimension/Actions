name: Codesign Product
description: Submit product to notary

inputs:
  sign:
    required: true
    type: string
  keychain:
    required: true
    type: string
  apple_id:
    required: true
    type: string 
  team_id:
    required: true
    type: string 
  password:
    required: true
    type: string 
  product_path:
    required: true
    type: string
  dmg_path:
    required: true
    type: string

outputs:
  product_path: 
    value: ${{ inputs.product_path }}
  dmg_path: 
    value: ${{ inputs.dmg_path }}
  notarization_status:
    value: ${{ steps.notarytool.outputs.notarization_status }}

runs:
  using: "composite"
  steps:

    - name: setup
      id: setup
      run: |
        echo "dmg_path=${{ inputs.dmg_path }}" >> $GITHUB_OUTPUT
        curl "${entitlements_url}" -o entitlements.plist -sL
        echo "entitlements_path=${GITHUB_WORKSPACE}/entitlements.plist" >> $GITHUB_OUTPUT
      shell: bash
      env:
        path: ${{ inputs.product_path }}
        entitlements_url: 'https://raw.githubusercontent.com/miyako/4D/v1/entitlements.plist'

    - name: Normalize ALL WebViewerCEF bundles (helpers exec must not be symlinks)
      shell: bash
      run: |
        set -euo pipefail
        shopt -s nullglob

        echo "üîé Scan des r√©pertoires *WebViewerCEF.bundle/Contents/Frameworks* dans ${GITHUB_WORKSPACE}"

        py_resolve='import os,sys; base=sys.argv[1]; tgt=sys.argv[2]; print(os.path.abspath(os.path.join(base, tgt)))'

        FOUND=0
        while IFS= read -r -d '' BUNDLE_ROOT; do
          FOUND=1
          echo "üì¶ Bundle: $BUNDLE_ROOT"

          SRC_CEF="${BUNDLE_ROOT}/Chromium Embedded Framework.framework"
          if [ ! -d "$SRC_CEF" ]; then
            echo "‚ùå CEF introuvable dans $BUNDLE_ROOT"; exit 1
          fi

          while IFS= read -r -d '' APP; do
            NAME="$(basename "$APP" .app)"
            EXE="$APP/Contents/MacOS/$NAME"

            # 1) L'ex√©cutable principal ne doit pas √™tre un symlink
            if [ -L "$EXE" ]; then
              TGT="$(readlink "$EXE")"
              RESOLVED=$(python3 -c "$py_resolve" "$(dirname "$EXE")" "$TGT")
              if [ ! -f "$RESOLVED" ]; then
                echo "‚ùå Cible du symlink introuvable: $EXE -> $TGT"; exit 1
              fi
              echo "ü™Ñ Remplace symlink ex√©cutable: $EXE  (-> $TGT)"
              rm -f "$EXE"
              /usr/bin/ditto "$RESOLVED" "$EXE"
              chmod 755 "$EXE"
            fi

            # 2) Chaque helper doit avoir sa copie locale du framework CEF
            DEST_CEF="$APP/Contents/Frameworks/Chromium Embedded Framework.framework"
            if [ -L "$DEST_CEF" ]; then
              echo "ü™Ñ Supprime symlink CEF dans $APP"
              rm -f "$DEST_CEF"
            fi
            if [ ! -d "$DEST_CEF" ]; then
              echo "üìö Copie CEF local dans: $DEST_CEF"
              /usr/bin/ditto "$SRC_CEF" "$DEST_CEF"
            fi

          done < <(find "$BUNDLE_ROOT" -type d -name "4D Helper*.app" -print0)

        done < <(find "${GITHUB_WORKSPACE}" -type d -path "*/WebViewerCEF.bundle/Contents/Frameworks" -print0)

        if [ $FOUND -eq 0 ]; then
          echo "‚ÑπÔ∏è Aucun WebViewerCEF.bundle trouv√© (ce n‚Äôest pas bloquant)"
        fi

    - name: Preflight ‚Äî aucun ex√©cutable de helper ne doit √™tre un symlink
      shell: bash
      run: |
        set -euo pipefail
        SYMLINKS_FOUND=0

        while IFS= read -r -d '' SYM; do
          if [ $SYMLINKS_FOUND -eq 0 ]; then
            echo "‚ùå Symlinks d'ex√©cutables trouv√©s :"
          fi
          echo " - $SYM"
          SYMLINKS_FOUND=1
        done < <(find "${GITHUB_WORKSPACE}" -type l -path "*/4D Helper*.app/Contents/MacOS/*" -print0)

        if [ $SYMLINKS_FOUND -eq 1 ]; then
          exit 1
        fi

        echo "‚úÖ OK ‚Äî aucun symlink executable dans les helpers"

    - name: Codesign
      shell: bash
      run: |
        set -euo pipefail

        echo "=== Codesign start for: ${product_path} ==="

        # retry_codesign : signe sans entitlements (r√©utilisable pour la plupart des items)
        retry_codesign() {
          local target="$1"
          local extra_opts="$2"
          local attempt=1
          local max_attempts=5
          local delay=3
          while [ $attempt -le $max_attempts ]; do
            echo "[$attempt/$max_attempts] codesign: $target (opts: $extra_opts)"
            output=$(codesign --verbose --force --options=runtime $extra_opts --sign "${sign}" --keychain "${keychain}" "$target" 2>&1) || true
            status=$?
            echo "$output"
            if [ $status -eq 0 ]; then
              echo "‚úÖ codesign succeeded: $target"
              return 0
            fi
            if echo "$output" | grep -qiE "no identity found|password|resource fork|not found in keychain|code object is not signed at all|The timestamp service is not available"; then
              echo "‚ùå Fatal codesign error for $target"
              echo "$output"
              return 1
            fi
            echo "‚ö†Ô∏è codesign attempt $attempt failed for $target ‚Äî retry in ${delay}s..."
            attempt=$((attempt+1))
            sleep $delay
            delay=$((delay * 2))
          done
          echo "‚ùå codesign ultimately failed for $target after $max_attempts attempts"
          return 1
        }

        # retry_codesign_with_entitlements : wrapper pour la signature finale (utilise entitlements)
        retry_codesign_with_entitlements() {
          local target="$1"
          local extra_opts="$2"
          local attempt=1
          local max_attempts=5
          local delay=3
          while [ $attempt -le $max_attempts ]; do
            echo "[$attempt/$max_attempts] codesign(with entitlements): $target (opts: $extra_opts)"
            output=$(codesign --verbose --force --options=runtime $extra_opts --sign "${sign}" --keychain "${keychain}" --entitlements "${entitlements_path}" "$target" 2>&1) || true
            status=$?
            echo "$output"
            if [ $status -eq 0 ]; then
              echo "‚úÖ codesign (with entitlements) succeeded: $target"
              return 0
            fi
            if echo "$output" | grep -qiE "no identity found|password|resource fork|not found in keychain|code object is not signed at all|The timestamp service is not available"; then
              echo "‚ùå Fatal codesign error for $target (entitlements)"
              echo "$output"
              return 1
            fi
            echo "‚ö†Ô∏è attempt $attempt failed ‚Äî retrying in ${delay}s..."
            attempt=$((attempt+1))
            sleep $delay
            delay=$((delay * 2))
          done
          echo "‚ùå failed to sign (with entitlements) $target"
          return 1
        }

        # helper : verify immediately the signed item, print diagnostics if fail
        verify_and_dump() {
          local target="$1"
          echo "üîé V√©rification codesign pour: $target"
          if ! codesign --verify --deep --strict --verbose=4 "$target" 2>&1; then
            echo "‚ùå Verification failed for $target ‚Äî dumping signature info:"
            codesign -d --verbose=4 "$target" 2>&1 || true
            lipo -info "$target" 2>/dev/null || file "$target" 2>/dev/null || true
            return 1
          else
            echo "‚úÖ Verification OK for $target"
            return 0
          fi
        }

        # helper : remove signature safely
        remove_sig() {
          local f="$1"
          if codesign --remove-signature "$f" 2>/dev/null; then
            echo "üßπ old signature removed: $f"
          else
            true
          fi
        }

        # sign_file_handling_universal : signe un fichier binaire, g√®re les fat/universal slices
        sign_file_handling_universal() {
          local file="$1"
          local opts="$2"   # ex: "--deep --timestamp" or "--timestamp"
          if lipo -info "$file" 2>/dev/null | grep -q "Architectures in the fat file"; then
            echo "üîß Detected universal binary, signing per-arch: $file"
            tmpdir=$(mktemp -d)
            trap 'rm -rf "$tmpdir"' RETURN
            archs=$(lipo -info "$file" 2>/dev/null | sed -n 's/.*are:\s*//p' || true)
            if [ -z "$archs" ]; then
              archs=$(lipo -info "$file" 2>/dev/null | sed -n 's/.*Architectures in the fat file: .* are: //p' || true)
            fi
            IFS=' ' read -r -a arch_array <<< "$archs"
            thin_files=()
            for a in "${arch_array[@]}"; do
              thin="$tmpdir/$(basename "$file").$a"
              echo "  ‚Ü≥ extracting slice $a -> $thin"
              lipo "$file" -thin "$a" -output "$thin"
              chmod +x "$thin" || true
              remove_sig "$thin"
              retry_codesign "$thin" "$opts" || { echo "‚ùå Failed signing thin slice $a of $file"; return 1; }
              verify_and_dump "$thin" || { echo "‚ùå Verification failed for thin slice $a of $file"; return 1; }
              thin_files+=("$thin")
            done
            merged="$tmpdir/merged_$(basename "$file")"
            echo "üîß Rebuilding universal binary -> $merged"
            lipo -create "${thin_files[@]}" -output "$merged" || { echo "‚ùå lipo -create failed"; return 1; }
            # preserve executable bit and replace original atomically
            chmod +x "$merged" || true
            mv "$merged" "$file"
            # resigner le binaire final apr√®s reconstruction
            remove_sig "$file"
            retry_codesign "$file" "$opts" || { echo "‚ùå Final sign of rebuilt universal failed: $file"; return 1; }
            verify_and_dump "$file" || { echo "‚ùå Verification failed after final sign of $file"; return 1; }
            return 0
          else
            remove_sig "$file"
            retry_codesign "$file" "$opts" || { echo "‚ùå Failed signing file: $file"; return 1; }
            verify_and_dump "$file" || { echo "‚ùå Verification failed for file: $file"; return 1; }
            return 0
          fi
        }

        # --- 0) Sanity: afficher identity disponible et variables
        echo "Using identity: ${sign}"
        security find-identity -v -p codesigning || true
        echo "product_path: ${product_path}"
        echo "entitlements_path: ${entitlements_path:-<none>}"

        # -------- ORDRE CORRECT : frameworks -> bundles/plugins/kext -> nested apps -> libs -> staging libs -> leaf executables -> final app

        # === √âtape C : frameworks (TOUS les frameworks dans le product_path, y compris ceux dans bundles) ===
        echo "=== √âtape C: Signing frameworks (global) ==="
        while IFS= read -r -d '' fw; do
          echo "üìò Framework: $fw"
          fwname="$(basename "$fw" .framework)"
          candidates=("$fw/Versions/A/$fwname" "$fw/Versions/Current/$fwname" "$fw/$fwname")
          found=""
          for c in "${candidates[@]}"; do
            if [ -f "$c" ]; then found="$c"; break; fi
          done
          if [ -z "$found" ]; then
            found=$(find "$fw" -type f -perm -111 -maxdepth 3 -print -quit || true)
          fi
          if [ -n "$found" ]; then
            echo "üîß Signing inner framework binary: $found"
            sign_file_handling_universal "$found" "--deep --timestamp" || { echo "‚ùå Failed signing framework inner: $found"; exit 1; }
          else
            echo "‚ö†Ô∏è Aucun binaire ex√©cutable trouv√© dans $fw"
          fi

          # sign dylibs inside framework
          while IFS= read -r -d '' dylib; do
            sign_file_handling_universal "$dylib" "--deep --timestamp" || { echo "‚ùå Failed signing dylib in fw: $dylib"; exit 1; }
          done < <(find "$fw" -type f -name "*.dylib" -print0)

          retry_codesign "$fw" "--deep --timestamp" || { echo "‚ùå Failed signing framework container: $fw"; exit 1; }
          verify_and_dump "$fw" || { echo "‚ùå Verification failed for framework container: $fw"; exit 1; }
        done < <(find "${product_path}" -type d -name "*.framework" -print0)

        # === √âtape D : Bundles / plugins / kext (signer containers apr√®s avoir sign√© tout ce qu'il y a dedans) ===
        echo "=== √âtape D: Signing bundles/plugins/kexts ==="
        while IFS= read -r -d '' bp; do
          echo "üîå Plugin/Bundle/Kext: $bp"
          # sign inner executable if present
          exe=$(find "$bp" -type f -perm -111 -maxdepth 6 -print -quit || true)
          if [ -n "$exe" ]; then
            echo "üîß signing inner exe: $exe"
            sign_file_handling_universal "$exe" "--deep --timestamp" || { echo "‚ùå Failed signing inner exe of bundle: $exe"; exit 1; }
          fi

          # sign nested frameworks/dylibs inside bundle if any (they were likely signed by global frameworks step but keep for safety)
          while IFS= read -r -d '' bpdylib; do
            sign_file_handling_universal "$bpdylib" "--deep --timestamp" || { echo "‚ùå Failed signing bpdylib: $bpdylib"; exit 1; }
          done < <(find "$bp" -type f -name "*.dylib" -print0)

          retry_codesign "$bp" "--deep --timestamp" || { echo "‚ùå Failed signing bundle container: $bp"; exit 1; }
          verify_and_dump "$bp" || { echo "‚ùå Verification failed for bundle container: $bp"; exit 1; }
        done < <(find "${product_path}" -type d \( -name "*.bundle" -o -name "*.plugin" -o -name "*.kext" \) -print0)

        # === √âtape E : nested .app (tout ce qui est .app √† l'int√©rieur du product_path sauf l'app racine) ===
        echo "=== √âtape E: Signing nested .app bundles ==="
        while IFS= read -r -d '' app; do
          # exclude top-level app itself
          if [[ "$app" == "${product_path}" ]]; then
            continue
          fi
          echo "üì¶ Internal app: $app"
          mainexe="$app/Contents/MacOS/$(basename "$app" .app)"
          if [ -f "$mainexe" ]; then
            echo "üîß main exe: $mainexe"
            sign_file_handling_universal "$mainexe" "--deep --timestamp" || { echo "‚ùå Failed signing nested main exe: $mainexe"; exit 1; }
          else
            exe=$(find "$app" -type f -perm -111 -maxdepth 6 -print -quit || true)
            if [ -n "$exe" ]; then
              sign_file_handling_universal "$exe" "--deep --timestamp" || { echo "‚ùå Failed signing nested fallback exe: $exe"; exit 1; }
            fi
          fi

          # sign dylibs inside nested app
          while IFS= read -r -d '' dylib; do
            sign_file_handling_universal "$dylib" "--deep --timestamp" || { echo "‚ùå Failed signing dylib in nested app: $dylib"; exit 1; }
          done < <(find "$app" -type f -name "*.dylib" -print0)

          retry_codesign "$app" "--deep --timestamp" || { echo "‚ùå Failed signing nested app container: $app"; exit 1; }
          verify_and_dump "$app" || { echo "‚ùå Verification failed for nested app container: $app"; exit 1; }
        done < <(find "${product_path}" -type d -name "*.app" -print0)

        # === √âtape B : libs et executables standards (hors framework/app) ===
        echo "=== √âtape B: Signing dylibs / .so / other executables (non-framework, non-app) ==="
        while IFS= read -r -d '' file; do
          echo "---- processing lib/exe: $file ----"
          sign_file_handling_universal "$file" "--deep --timestamp" || { echo "‚ùå Failed signing lib/exe: $file"; exit 1; }
        done < <(find "${product_path}" -type f \( -name "*.dylib" -o -name "*.so" -o -perm -111 \) \
                ! -path "*.framework/*" ! -path "*.app/*" ! -path "*/Contents/MacOS/*" ! -path "*.4dbase/*" ! -path "*.4darchive/*" -print0)

        # === √âtape X : SIGNER LES dylibs situ√©s DANS LE REPERTOIRE DE STAGING (√† c√¥t√© de l'app) ===
        echo "=== √âtape X: Signing dylibs in staging dir (sibling of the .app) ==="
        staging_dir="$(dirname "${product_path}")"
        echo "Staging dir detected: ${staging_dir}"
        while IFS= read -r -d '' lib; do
          echo "üîß Signing staging lib: $lib"
          sign_file_handling_universal "$lib" "--deep --timestamp" || { echo "‚ùå Failed signing staging lib: $lib"; exit 1; }
        done < <(find "${staging_dir}" -type f \( -name "*.dylib" -o -name "*.so" \) ! -path "${product_path}/*" -print0 || true)

        # === √âtape A : executables internes (Contents/MacOS) - SIGN AFTER inner components ===
        echo "=== √âtape A: Signing executables in Contents/MacOS/ (now) ==="
        while IFS= read -r -d '' exe; do
          echo "---- processing: $exe ----"
          sign_file_handling_universal "$exe" "--deep --timestamp" || { echo "‚ùå Failed signing leaf exe: $exe"; exit 1; }
        done < <(find "${product_path}" -type f -path "*/Contents/MacOS/*" -perm -111 ! -path "*.4dbase/*" ! -path "*.4darchive/*" -print0)

        # === √âtape F : Signature finale de l‚Äôapp principale ===
        if [[ "${product_path}" == *.app ]]; then
          echo "=== √âtape F: Final signing of top-level app (with entitlements if any) ==="
          if [[ -n "${entitlements_path-}" && -f "${entitlements_path}" ]]; then
            retry_codesign_with_entitlements "${product_path}" "--deep --timestamp" || { echo "‚ùå Final sign (with entitlements) failed"; exit 1; }
          else
            retry_codesign "${product_path}" "--deep --timestamp" || { echo "‚ùå Final sign failed"; exit 1; }
          fi

          echo "üîé Final verification of top-level app"
          if ! codesign --verify --deep --strict --verbose=4 "${product_path}" 2>&1; then
            echo "‚ùå Final verification failed for ${product_path}"
            codesign -d --verbose=4 "${product_path}" || true
            exit 1
          fi

          if command -v spctl >/dev/null 2>&1; then
            echo "üîê spctl check for gatekeeper:"
            spctl -a -vv --type execute "${product_path}" || true
          fi
        else
          echo "‚ÑπÔ∏è product_path is not an .app; skipping final entitlements signing"
        fi

        echo "=== Codesign finished successfully ==="

      env:
        sign: ${{ inputs.sign }}
        keychain: ${{ inputs.keychain }}
        product_path: ${{ inputs.product_path }}
        entitlements_path: ${{ steps.setup.outputs.entitlements_path }}

    - name: hdiutil (sparse -> convert)
      id: hdiutil
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      shell: bash
      env:
        product_path: ${{ inputs.product_path }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}
        FS: HFS+                 # ou APFS si tu pr√©f√®res
        FORMAT: UDBZ             # UDBZ (bzip2) ou UDZO (zlib)
        MARGIN_PCT: "50"         # marge % au-dessus de la taille source
        EXTRA_MB: "500"          # marge fixe suppl√©mentaire en MB
        VERIFY: "1"              # 0 pour d√©sactiver verify
      run: |
        set -euo pipefail

        SRC="${product_path}"
        OUT="${dmg_path}"
        VOLNAME="$(basename "${OUT%.dmg}")"
        WORKDIR="$(mktemp -d /tmp/dmgbuild.XXXXXX)"
        MOUNT_DIR="${WORKDIR}/mnt"
        mkdir -p "$MOUNT_DIR"

        # Estimation taille
        SRC_KB=$(du -sk "$SRC" | awk '{print $1}')
        SRC_MB=$(( SRC_KB / 1024 ))
        if [[ $SRC_MB -lt 1 ]]; then SRC_MB=1; fi
        NEEDED_MB=$(( SRC_MB + (SRC_MB * ${MARGIN_PCT} / 100) + ${EXTRA_MB} ))
        if [[ $NEEDED_MB -lt 300 ]]; then NEEDED_MB=300; fi

        # Sparse + montage
        hdiutil create -type SPARSE -fs "${FS}" -volname "${VOLNAME}" -nospotlight \
          -size "${NEEDED_MB}m" -ov "${WORKDIR}/staging.sparseimage"

        hdiutil attach "${WORKDIR}/staging.sparseimage" -nobrowse -noverify -noautoopen -owners on \
          -mountpoint "${MOUNT_DIR}"

        # Copie
        rsync -a --delete "${SRC}" "${MOUNT_DIR}/"

        # D√©montage
        sync
        hdiutil detach "${MOUNT_DIR}" || hdiutil detach -force "${MOUNT_DIR}" || true

        # Compact + conversion
        hdiutil compact "${WORKDIR}/staging.sparseimage" || true
        hdiutil convert "${WORKDIR}/staging.sparseimage" -format "${FORMAT}" -o "${OUT}" -ov

        # Verify optionnel
        if [[ "${VERIFY}" == "1" ]]; then
          hdiutil verify "${OUT}"
        fi

        echo "[‚úì] DMG pr√™t: ${OUT}"

    - name: Debug notarization env vars
      id: debug-notarization
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      run: |
        echo "Apple ID: ${apple_id}"
        echo "Team ID: ${team_id}"
        echo "Password is set: [${#password} characters]"
      shell: bash
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}

    - name: Notarize with Apple NotaryTool and check result (polling)
      id: notarytool
      if: ${{ !contains(inputs.product_path, 'update.mac.4darchive') }}
      shell: bash
      run: |
        set -euo pipefail

        echo "üì¶ Soumission √† Apple NotaryTool..."
        json_output_file="notarytool-submit.json"
        status_file="${GITHUB_WORKSPACE}/notarization_status.txt"

        # soumission (sans --wait)
        xcrun notarytool submit "${dmg_path}" \
          --apple-id "${apple_id}" \
          --team-id "${team_id}" \
          --password "${password}" \
          --output-format json >"$json_output_file"

        echo "üìÑ JSON submit:"
        cat "$json_output_file" || true

        submission_id=$(jq -r '.id // empty' "$json_output_file")
        if [[ -z "$submission_id" ]]; then
          echo "‚ùå Impossible de r√©cup√©rer l‚ÄôID de soumission"
          exit 1
        fi
        echo "üÜî Soumission envoy√©e, ID=$submission_id"

        # Polling (10s) jusqu'√† 1h (360 tentatives)
        attempt=0
        max_attempts=360
        status="In Progress"
        while [[ "$status" == "In Progress" && $attempt -lt $max_attempts ]]; do
          sleep 10
          attempt=$((attempt+1))
          echo "‚è≥ V√©rification notarisation (tentative $attempt)..."
          out=$(xcrun notarytool info "$submission_id" \
            --apple-id "${apple_id}" \
            --team-id "${team_id}" \
            --password "${password}" \
            --output-format json 2>/dev/null || true)
          status=$(echo "$out" | jq -r '.status // empty')
          echo "Statut actuel: ${status:-unknown}"

          # Optionnel: √©crire l‚Äôinstantan√© JSON pour debug
          echo "$out" > "notarytool-info-$attempt.json" || true
        done

        echo "${status:-Unknown}" > "$status_file"
        echo "notarization_status=${status:-Unknown}" >> $GITHUB_OUTPUT

        if [[ "$status" == "Accepted" ]]; then
          echo "‚úÖ Notarisation r√©ussie"
          exit 0
        elif [[ "$status" == "Invalid" ]]; then
          echo "‚ùå Notarisation rejet√©e (Invalid)"
          xcrun notarytool log "$submission_id" \
            --apple-id "${apple_id}" \
            --team-id "${team_id}" \
            --password "${password}" \
            --output-format json || true
          exit 1
        else
          echo "‚ùå Notarisation non termin√©e ou statut inattendu: '${status:-Unknown}'"
          exit 1
        fi
      env:
        apple_id: ${{ inputs.apple_id }}
        team_id: ${{ inputs.team_id }}
        password: ${{ inputs.password }}
        dmg_path: ${{ steps.setup.outputs.dmg_path }}
